package SMPL.syntax;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import SMPL.values.*;
import SMPL.semantics.*;


/* Preliminaries to set up and use the scanner.  */
parser code {:
		SMPLLexer lexer;

		public SMPLParser(SMPLLexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Encountered token " + cur_token +
					": " + lexer.getText());
		}
	    :};

/* Terminals (tokens returned by the scanner). */
// commands
terminal PAIR, ISPAIR, CAR, CDR, LIST, SIZE, ISEQV, ISEQUAL, SUBSTR, ELIST;

// special symbols
terminal LPAREN, RPAREN, COLON, LBRACE, RBRACE, LBRACK, RBRACK, COMMA, SEMI, DOT;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, EXP;
// bitwise bool
terminal BITAND, BITOR, BITNOT;
// logical operators
terminal LESS, MORE, EQUAL, LRE, MRE, NE;
// boolean symbols
terminal NOT, AND, OR;
// string operator
terminal CONCAT;

// other commands
terminal DEFINE, LET, PROC, CALL, LAZY, CASE;
terminal PROCEDURE, IF, THEN, ELSE;
terminal PRINT, PRINTLN, READ, READINT, LCOMMENT, SCOMMENT, ECOMMENT;

// terminals with values
terminal Integer INT;
terminal Integer BINARY;
terminal Integer HEX;
terminal Boolean TRUE;
terminal Boolean FALSE;
terminal Double FLOAT;
terminal String ID;
terminal String STR;
terminal Character CHAR;
terminal String UNI;

/* Non terminals */
non terminal ASTProgram program;
non terminal ASTExpSequence expSeq;
non terminal ASTExp stmt;
non terminal ASTExp condition;
non terminal ASTExp proc;
non terminal ASTExp def;

non terminal ASTExpList expList;
non terminal ASTExpList expListAux;
non terminal ASTExp expression;
non terminal ASTExp valExp;
non terminal ASTExp caseExp;
non terminal ASTExp exp;
non terminal ASTExp term;
non terminal ASTExp factor;
non terminal ASTExp boolExp;
non terminal ASTExp boolVal;
non terminal ASTExp andExp;
non terminal ASTExp notExp;
non terminal ASTExp logExp;
non terminal ASTExp bitLog;
non terminal ASTExp bitNeg;
non terminal Binding binding;
non terminal Clause pred;
non terminal ASTExp sysExp;
non terminal ArrayList<Binding> bindings;
non terminal ArrayList<Clause> predList;
non terminal PrimitiveValue number;
non terminal ArrayList<String> idList;
non terminal ArrayList<String> idListAux;
non terminal empty;

precedence right COMMA;
precedence left IF,LET,CASE,CALL,READ,READINT,PRINT,PRINTLN;
precedence left PROCEDURE,DEFINE,SEMI,LCOMMENT,SCOMMENT;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left EQUAL, LESS, MORE, LRE, MRE, NE;
precedence left BITAND, BITOR;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence left BITNOT;
precedence right LPAREN,LBRACE,LBRACK;
precedence nonassoc ID, INT, BINARY, HEX, FLOAT, TRUE, FALSE, STR, CHAR, UNI,LAZY;

/* Grammar rules */

program ::= expSeq:l  {: RESULT = new ASTProgram(l); :};

expSeq ::= expSeq:l exp:s {: RESULT = l.add(s); :} |
	     exp:s {: RESULT = new ASTExpSequence(s); :};

exp ::= stmt:s {: RESULT = s; :} |
        boolExp:v {: RESULT = v; :} | 
        valExp:v {:RESULT = v; :} |
        expList:l {:  RESULT = l; :} |
        sysExp:e {: RESULT = e; :};

stmt ::= proc:p {:
                RESULT=p;
                :} |
         def:d {:
                RESULT = d;
                :} |
         boolExp:e SEMI {:
                RESULT = e;
                :} |
         valExp:v SEMI {:
                RESULT = v; 
                :}
                ;

proc ::= PROCEDURE LPAREN LBRACE idList:id RBRACE RPAREN expSeq:l SEMI {:
                    RESULT = new ASTProcDef(id,l);
                :}|
         PROCEDURE LPAREN idList:id DOT ID:i RPAREN expSeq:l SEMI{:
                    RESULT = new ASTProcDef(id,i,l);
                :}|
         PROCEDURE ID:id expSeq:l SEMI {:
                    RESULT = new ASTProcDef(id,l);
                :}
                ;

def ::=  DEFINE ID:i exp:e SEMI {:
                RESULT = new ASTDefine(i,e);
                :}|
         idList:i COLON EQUAL exp:e SEMI {:
                RESULT = new ASTDefine(i,e);
                :};

idList ::= ID:i idListAux:l {:
                    l.add(i);
                    RESULT = l;
                :};

idListAux ::= COMMA ID:i idListAux:l {:
                    l.add(i);
                    RESULT = l;
                :} |
            empty {: RESULT = new ArrayList<String>();:}
                ;

bindings ::= bindings:bl COMMA binding:b {:
                    bl.add(b);
                    RESULT = bl;
                :} |
             binding:b {:
                    ArrayList<Binding> bl = new ArrayList<Binding>();
                    bl.add(b);
                    RESULT = bl;
                :};

binding ::= ID:i EQUAL exp:e {:
                RESULT = new Binding(i,e);
             :};


expList ::= valExp:l COMMA expListAux:a {: a.add(l); RESULT = a; :};

expListAux ::= valExp:v expListAux:a {:
                    a.add(v);
                    RESULT = a;
                    :} |
            empty {: RESULT = new ASTExpList(); :};

valExp ::= LET LPAREN bindings:b RPAREN expSeq:s {:
                    RESULT = new ASTLet(b,s);
                :}|
           CALL LPAREN ID:i COMMA exp:l RPAREN {: 
                    RESULT= new ASTProcCall(i,l);
                :}|
           ID:i LPAREN exp:l RPAREN {:
                    RESULT = new ASTProcCall(i,l);
                :}|
           CASE LBRACK LBRACE predList:p RBRACE RBRACK {:
                    RESULT = new ASTCase(p);
                :}|
            LBRACK expSeq:e RBRACK {:
                    RESULT = e;
                :}|
            LPAREN expList:e RPAREN {:
                    RESULT = e;
                :}|
           condition:c {: RESULT=c; :}|
           expression:e {: RESULT = e; :};

condition ::= IF boolExp:e THEN expSeq:s {:
                    RESULT = new ASTConditional(e,s);
                :} |
              IF boolExp:e THEN expSeq:s LBRACE ELSE expSeq:f RBRACE{:
                    RESULT = new ASTConditional(e,s,f);
                :};

predList ::= pred:p COMMA  predList:l {:
                    l.add(p);
                    RESULT = l;
                :} |
             empty {: RESULT = new ArrayList<Clause>(); :};

pred ::= boolExp:b COLON exp:e {:
                    RESULT = new Clause(b,e);
                :}|
         ELSE COLON  exp:e {:
                    RESULT = new Clause(new ASTExpLit(PrimitiveValue.make(true)),e);
                :};

sysExp ::= READ LPAREN RPAREN {:
                    RESULT = new ASTRead();
                :}|
           READINT LPAREN RPAREN {:
                    RESULT = new ASTReadInt();
                :}|
           PRINT LPAREN exp:e RPAREN {:
                    RESULT = new ASTPrint(e);
                :}|
           PRINTLN LPAREN exp:e RPAREN {:
                    RESULT = new ASTPrintLn(e);
                :}|
           LCOMMENT STR:s {:
                    RESULT = new ASTComment(s);
                :}|
           SCOMMENT STR:s ECOMMENT {:
                    RESULT = new ASTComment(s);
                :};

boolExp ::= boolExp:log OR andExp:le {:
                RESULT = new ASTExpOr(log,le);
            :} |
            andExp:e {: RESULT = e; :};

andExp ::= andExp:log AND notExp:le {:
                RESULT = new ASTExpAnd(log,le);
            :} |
            notExp:e {: RESULT = e; :};

notExp ::= NOT logExp:log {: RESULT = new ASTExpNot(log); :} |
            logExp:log {: RESULT = log; :};

logExp ::= logExp:e LESS bitLog:ex {:
                RESULT = new ASTExpLess(e,ex);
            :} |
           logExp:e MORE bitLog:ex {:
                RESULT = new ASTExpMore(e,ex);    
            :} |
           logExp:e EQUAL bitLog:ex {:
                RESULT = new ASTExpEqual(e,ex);
            :} |
           logExp:e LRE bitLog:ex {:
                RESULT = new ASTExpLRE(e,ex);
            :} |
           logExp:e MRE bitLog:ex {:
                RESULT = new ASTExpMRE(e,ex);
            :} |
           logExp:e NE bitLog:ex {:
                RESULT = new ASTExpNE(e,ex);
            :} |
            bitLog:b {: RESULT=b; :}
            ;

bitLog ::= bitLog:b BITAND expression:e {:
                    RESULT = new ASTBitAnd(b,e); 
            :} |
            bitLog:b BITOR expression:e {:
                    RESULT = new ASTBitOr(b,e);
            :} |
            boolVal:b {: RESULT = b; :};

boolVal ::= TRUE {: RESULT = new ASTExpLit(PrimitiveValue.make(true)); :} |
            FALSE {: RESULT = new ASTExpLit(PrimitiveValue.make(false)); :};

expression ::= 	expression:e PLUS term:t {:
			RESULT = new ASTExpAdd(e, t); :} |
		expression:e MINUS term:t {:
			RESULT = new ASTExpSub(e, t); :} |
		term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {:
		RESULT = new ASTExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ASTExpDiv(t, f); :} |
	 term:t MOD factor:f {:
		RESULT = new ASTExpMod(t, f); :} |
         bitNeg:b {: RESULT = b; :};

bitNeg ::= BITNOT factor:f {: RESULT = new ASTBitNot(f); :} |
            factor:f {: RESULT = f; :};

factor ::= number:ilit {: RESULT = new ASTExpLit(ilit); :} |
           ID:v {: RESULT = new ASTExpVar(v); :} |
           STR:s {: RESULT = new ASTExpStr(s); :} |
           CHAR:c {: RESULT = new ASTExpChar(c); :} |
           UNI:u {: RESULT = new ASTExpUni(u); :} |
	   LPAREN expression:e RPAREN {: RESULT = e; :}	|
           LBRACE expression:e RBRACE {: RESULT = e; :} |
           LAZY LPAREN expression:e RPAREN {: RESULT = new ASTLazyExp(e); :};

number ::= INT:i {: RESULT = PrimitiveValue.make(i); :} |
           HEX:h {: RESULT = PrimitiveValue.make(h); :} |
           BINARY: b {: RESULT = PrimitiveValue.make(b); :} |
           FLOAT:r {: RESULT = PrimitiveValue.make(r); :} ;

empty ::= ;
